# Cursor IDE Rules for Enterprise Smart Contract Platform

## 🎯 Project Vision
This is an enterprise-grade smart contract and wallet platform following patterns from major financial companies like Robinhood, Binance, and Coinbase. Focus on security, scalability, and professional standards.

## 🏗️ Architecture Principles

### Hexagonal Architecture (Ports & Adapters)
- Domain logic in center, infrastructure on edges
- Use interfaces/ports for external dependencies
- Adapters implement concrete integrations
- Clear separation of concerns

### Domain-Driven Design (DDD)
- Rich domain models with business logic
- Value objects for primitive obsession
- Aggregate roots for consistency boundaries
- Domain events for decoupling

## 📝 Code Style Guidelines

### Python (Backend)
```python
# Use type hints everywhere
from typing import Optional, List, Dict, Any
from dataclasses import dataclass
from abc import ABC, abstractmethod

# Naming conventions
class SmartContractService:  # PascalCase for classes
    async def mint_token(self, token_data: TokenData) -> TokenId:  # snake_case for methods
        pass

# Constants in UPPER_CASE
MAX_TOKEN_SUPPLY = 1000000
DEFAULT_GAS_LIMIT = 300000

# Use dataclasses for data structures
@dataclass(frozen=True)
class WalletAddress:
    value: str
    
    def __post_init__(self):
        if not self.value.startswith('0x'):
            raise ValueError("Invalid address format")
```

### Solidity (Smart Contracts)
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

// Interface naming: I + PascalCase
interface ITokenContract {
    function mint(address to, uint256 amount) external;
}

// Contract naming: PascalCase
contract TokenContract is ITokenContract {
    // Constants: UPPER_CASE
    uint256 public constant MAX_SUPPLY = 1000000;
    
    // State variables: camelCase
    mapping(address => uint256) public balanceOf;
    
    // Custom errors for gas optimization
    error InsufficientBalance();
    error InvalidAddress();
    
    // Modifiers: camelCase
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }
}
```

### TypeScript (Frontend Integration)
```typescript
// Interface naming: PascalCase
interface WalletConfig {
  networkId: number;
  contractAddress: string;
}

// Use readonly for immutable data
type ContractAddress = Readonly<{
  value: string;
  network: string;
}>;

// Async/await over promises
async function mintToken(params: MintParams): Promise<TransactionHash> {
  // Implementation
}
```

## 🔐 Security Guidelines

### Smart Contract Security
- Always use reentrancy guards on external calls
- Implement proper access control with OpenZeppelin
- Use custom errors instead of require strings
- Validate all inputs extensively
- Emit events for all state changes
- Use SafeMath for arithmetic operations

```solidity
// Good
function transfer(address to, uint256 amount) external nonReentrant {
    if (to == address(0)) revert InvalidAddress();
    if (amount > balanceOf[msg.sender]) revert InsufficientBalance();
    
    balanceOf[msg.sender] -= amount;
    balanceOf[to] += amount;
    
    emit Transfer(msg.sender, to, amount);
}
```

### Backend Security
- Never expose private keys in responses
- Use environment variables for sensitive data
- Implement rate limiting on all endpoints
- Validate all input parameters
- Use structured logging for audit trails

## 🧪 Testing Standards

### Smart Contract Tests
```javascript
describe("TokenContract", function () {
  let contract, owner, user1, user2;
  
  beforeEach(async function () {
    // Setup fresh contract for each test
  });
  
  describe("Minting", function () {
    it("should mint tokens to specified address", async function () {
      // Arrange
      const amount = ethers.utils.parseEther("100");
      
      // Act
      await contract.mint(user1.address, amount);
      
      // Assert
      expect(await contract.balanceOf(user1.address)).to.equal(amount);
    });
  });
});
```

### Backend Tests
```python
@pytest.mark.asyncio
async def test_create_wallet():
    # Arrange
    web3_client = Web3ClientImpl()
    
    # Act
    address, private_key = await web3_client.create_wallet("password")
    
    # Assert
    assert address.value.startswith("0x")
    assert len(address.value) == 42
```

## 📁 File Organization

### Directory Structure
```
project/
├── contracts/           # Smart contracts
│   ├── interfaces/     # Contract interfaces
│   ├── libraries/      # Reusable libraries
│   └── tokens/         # Token implementations
├── backend/
│   ├── app/
│   │   ├── core/       # Domain layer
│   │   ├── adapters/   # Infrastructure
│   │   └── api/        # Application layer
├── frontend/
│   ├── components/     # React components
│   ├── hooks/          # Custom hooks
│   └── utils/          # Utility functions
└── tests/              # All tests
```

### Naming Conventions
- Files: `snake_case.py`, `PascalCase.sol`, `camelCase.ts`
- Directories: `snake_case` or `kebab-case`
- Environment files: `.env.example`, `.env.local`

## 🔧 Development Workflow

### Git Commit Messages
```
feat: add token minting functionality
fix: resolve reentrancy vulnerability in transfer
docs: update smart contract documentation
test: add comprehensive wallet tests
refactor: improve gas efficiency in marketplace
```

### Branch Naming
- `feature/token-staking`
- `fix/wallet-balance-bug`
- `docs/api-documentation`
- `test/integration-tests`

## 🚀 Performance Guidelines

### Smart Contract Optimization
- Pack structs to minimize storage slots
- Use `uint256` instead of smaller uints when possible
- Batch operations when feasible
- Implement lazy deletion patterns
- Use events instead of storage for non-critical data

### Backend Optimization
- Use async/await for I/O operations
- Implement connection pooling for databases
- Cache frequently accessed data with Redis
- Use background tasks for heavy operations
- Implement proper pagination for large datasets

## 📊 Monitoring & Logging

### Structured Logging
```python
import structlog

logger = structlog.get_logger(__name__)

logger.info(
    "Transaction processed",
    transaction_hash=tx_hash,
    from_address=from_addr,
    to_address=to_addr,
    amount=amount,
    gas_used=gas_used
)
```

### Metrics Collection
- Track transaction counts and volumes
- Monitor gas usage patterns
- Measure API response times
- Count error rates by type
- Track wallet creation and activity

## 🔍 Code Review Checklist

### Before Submitting PR
- [ ] All tests pass
- [ ] Code coverage > 90%
- [ ] No hardcoded secrets
- [ ] Proper error handling
- [ ] Documentation updated
- [ ] Gas optimization considered
- [ ] Security review completed

### Smart Contract Specific
- [ ] Reentrancy protection
- [ ] Access control implemented
- [ ] Input validation complete
- [ ] Events emitted for state changes
- [ ] Gas optimization applied
- [ ] Upgrade mechanism secure

## 📚 Documentation Standards

### Function Documentation
```python
async def mint_token(
    self,
    contract_address: ContractAddress,
    to_address: WalletAddress,
    metadata: TokenMetadata
) -> Tuple[int, TransactionHash]:
    """
    Mint a new token to the specified address.
    
    Args:
        contract_address: The smart contract address
        to_address: Recipient wallet address
        metadata: Token metadata including URI and properties
        
    Returns:
        Tuple of (token_id, transaction_hash)
        
    Raises:
        ContractInteractionError: If minting fails
        ValueError: If invalid parameters provided
    """
```

### README Structure
1. Overview and architecture
2. Quick start guide
3. Installation instructions
4. Configuration details
5. API documentation
6. Testing instructions
7. Deployment guide
8. Contributing guidelines

## 🎯 Quality Gates

### Definition of Done
- Feature implemented and tested
- Documentation updated
- Security review passed
- Performance benchmarks met
- Code review approved
- CI/CD pipeline passes

### Never Allow
- Hardcoded private keys or secrets
- Unbounded loops in smart contracts
- Missing error handling
- Untested critical paths
- Breaking changes without migration
- Security vulnerabilities

## 🔗 Integration Guidelines

### External Service Integration
- Always use retry logic with exponential backoff
- Implement circuit breakers for critical services
- Use timeout configurations
- Log all external calls
- Handle partial failures gracefully

### Blockchain Integration
- Use proper gas estimation
- Implement transaction monitoring
- Handle network congestion
- Support multiple networks
- Validate all on-chain data

---

**Remember**: We're building enterprise-grade financial infrastructure. Every line of code should meet the standards of companies like Robinhood, Binance, and Coinbase. Security, reliability, and performance are non-negotiable. 